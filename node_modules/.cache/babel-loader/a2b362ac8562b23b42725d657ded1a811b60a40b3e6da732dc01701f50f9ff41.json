{"ast":null,"code":"// Sun.js\nimport * as THREE from 'three';\nexport default class Sun {\n  constructor(position = {\n    x: 0,\n    y: 0,\n    z: 0\n  }) {\n    // 创建太阳的主场景\n    this.scene = new THREE.Scene();\n\n    // 创建几何体\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\n\n    // 创建主太阳材质\n    const materialSun = new THREE.ShaderMaterial({\n      vertexShader: this.sunVertexTexture(),\n      fragmentShader: this.sunFragmentTexture(),\n      side: THREE.DoubleSide,\n      uniforms: {\n        uTime: {\n          value: 0\n        },\n        uPerlin: {\n          value: null\n        }\n      }\n    });\n\n    // 创建太阳网格并添加到场景中\n    this.Sun = new THREE.Mesh(geometry, materialSun);\n    this.Sun.position.set(position.x, position.y, position.z);\n    this.scene.add(this.Sun);\n  }\n\n  // 定义太阳的顶点着色器\n  sunVertexTexture() {\n    return `\n    uniform float uTime;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    //旋转矩阵\n    mat2 rotate(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c,-s,s,c);\n    } \n\n    void main()\n    {\n        // uv坐标\n        vUv = uv;\n        // 顶点法线\n        vNormal = normal;\n        // 世界坐标系\n        vec4 WorldPosition = modelMatrix * vec4 (position,1.0);\n        // 顶点到相机的向量\n        eyeVector = normalize(WorldPosition.xyz - cameraPosition);\n\n        // 分别求围绕各个轴所进行的顶点旋转\n        float t = uTime * 0.03;\n        mat2 rot = rotate(t);\n\n        vec3 p0 = position;\n        p0.yz = rot * p0.yz;\n        vLayer0 = p0;\n\n        mat2 rot1 = rotate(t+10.0);\n        vec3 p1 = position;\n        p1.xz = rot1 * p1.xz;\n        vLayer1 = p1;\n\n        mat2 rot2 = rotate(t+30.0);\n        vec3 p2 = position;\n        p2.xy = rot2 * p2.xy;\n        vLayer2 = p2; \n\n        vPosition = position;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义太阳的片段着色器\n  sunFragmentTexture() {\n    return `\n    uniform float uTime;\n    varying vec2 vUv;\n    uniform samplerCube uPerlin;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    const float PI = 3.14159265359;\n\n    vec3 brightnessToColor (float b){\n      b *=0.25;\n      return (vec3(b, b*b, b*b*b*b)/0.25)*0.7;\n    }\n\n    // 将各个图层的纹理叠加整合\n    float sun(){\n      float sum = 0.0;\n      sum +=textureCube(uPerlin,vLayer0).r;\n      sum +=textureCube(uPerlin,vLayer1).r;\n      sum +=textureCube(uPerlin,vLayer2).r;\n      sum *=0.40;\n      return sum;\n    }\n\n    // 菲涅耳计算\n    float Fresnel(vec3 eyeVector,vec3 worldNormal){\n        return pow(1.3 + dot(eyeVector,worldNormal),4.0);\n    }\n\n    void main()\n    {\n      // 获取纹理\n      float brightness = sun();\n      // 增加对比度\n      brightness = brightness*4.0+1.0;\n      // 菲涅耳计算模拟反射和折射的光照\n      float fres = Fresnel(eyeVector,vNormal);\n      brightness += fres;\n      // 获取太阳的颜色\n      vec3 color = brightnessToColor(brightness); \n      gl_FragColor = vec4(color,1.0);\n    }`;\n  }\n\n  // 更新函数，在动画循环中调用\n  update(elapsedTime, renderer) {\n    // 更新着色器中的 uTime\n    this.materialSun.uniforms.uTime.value = elapsedTime;\n    this.materialnoise.uniforms.uTime.value = elapsedTime;\n\n    // 更新 cubeCamera\n    this.cubeCamera.update(renderer, this.textureScene);\n\n    // 设置 uPerlin 为渲染目标的纹理\n    this.materialSun.uniforms.uPerlin.value = this.cubeRenderTarget.texture;\n  }\n}","map":{"version":3,"names":["THREE","Sun","constructor","position","x","y","z","scene","Scene","geometry","SphereGeometry","materialSun","ShaderMaterial","vertexShader","sunVertexTexture","fragmentShader","sunFragmentTexture","side","DoubleSide","uniforms","uTime","value","uPerlin","Mesh","set","add","update","elapsedTime","renderer","materialnoise","cubeCamera","textureScene","cubeRenderTarget","texture"],"sources":["E:/three.js/three.js-demo/three-city/city/src/three/mesh/sun.js"],"sourcesContent":["// Sun.js\r\nimport * as THREE from 'three';\r\n\r\nexport default class Sun {\r\n  constructor(position={x:0,y:0,z:0}) {\r\n    // 创建太阳的主场景\r\n    this.scene = new THREE.Scene();\r\n\r\n    // 创建几何体\r\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\r\n\r\n    // 创建主太阳材质\r\n    const materialSun = new THREE.ShaderMaterial({\r\n      vertexShader: this.sunVertexTexture(),\r\n      fragmentShader: this.sunFragmentTexture(),\r\n      side: THREE.DoubleSide,\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n        uPerlin: { value: null }\r\n      }\r\n    });\r\n\r\n    // 创建太阳网格并添加到场景中\r\n    this.Sun = new THREE.Mesh(geometry, materialSun);\r\n    this.Sun.position.set(position.x, position.y, position.z);\r\n    this.scene.add(this.Sun);\r\n  }\r\n\r\n  // 定义太阳的顶点着色器\r\n  sunVertexTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    varying vec2 vUv;\r\n    varying vec3 vPosition;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    varying vec3 vNormal;\r\n\r\n    //旋转矩阵\r\n    mat2 rotate(float a){\r\n        float s = sin(a);\r\n        float c = cos(a);\r\n        return mat2(c,-s,s,c);\r\n    } \r\n\r\n    void main()\r\n    {\r\n        // uv坐标\r\n        vUv = uv;\r\n        // 顶点法线\r\n        vNormal = normal;\r\n        // 世界坐标系\r\n        vec4 WorldPosition = modelMatrix * vec4 (position,1.0);\r\n        // 顶点到相机的向量\r\n        eyeVector = normalize(WorldPosition.xyz - cameraPosition);\r\n\r\n        // 分别求围绕各个轴所进行的顶点旋转\r\n        float t = uTime * 0.03;\r\n        mat2 rot = rotate(t);\r\n\r\n        vec3 p0 = position;\r\n        p0.yz = rot * p0.yz;\r\n        vLayer0 = p0;\r\n\r\n        mat2 rot1 = rotate(t+10.0);\r\n        vec3 p1 = position;\r\n        p1.xz = rot1 * p1.xz;\r\n        vLayer1 = p1;\r\n\r\n        mat2 rot2 = rotate(t+30.0);\r\n        vec3 p2 = position;\r\n        p2.xy = rot2 * p2.xy;\r\n        vLayer2 = p2; \r\n\r\n        vPosition = position;\r\n\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义太阳的片段着色器\r\n  sunFragmentTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    varying vec2 vUv;\r\n    uniform samplerCube uPerlin;\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    const float PI = 3.14159265359;\r\n\r\n    vec3 brightnessToColor (float b){\r\n      b *=0.25;\r\n      return (vec3(b, b*b, b*b*b*b)/0.25)*0.7;\r\n    }\r\n\r\n    // 将各个图层的纹理叠加整合\r\n    float sun(){\r\n      float sum = 0.0;\r\n      sum +=textureCube(uPerlin,vLayer0).r;\r\n      sum +=textureCube(uPerlin,vLayer1).r;\r\n      sum +=textureCube(uPerlin,vLayer2).r;\r\n      sum *=0.40;\r\n      return sum;\r\n    }\r\n\r\n    // 菲涅耳计算\r\n    float Fresnel(vec3 eyeVector,vec3 worldNormal){\r\n        return pow(1.3 + dot(eyeVector,worldNormal),4.0);\r\n    }\r\n\r\n    void main()\r\n    {\r\n      // 获取纹理\r\n      float brightness = sun();\r\n      // 增加对比度\r\n      brightness = brightness*4.0+1.0;\r\n      // 菲涅耳计算模拟反射和折射的光照\r\n      float fres = Fresnel(eyeVector,vNormal);\r\n      brightness += fres;\r\n      // 获取太阳的颜色\r\n      vec3 color = brightnessToColor(brightness); \r\n      gl_FragColor = vec4(color,1.0);\r\n    }`;\r\n  }\r\n\r\n  // 更新函数，在动画循环中调用\r\n  update(elapsedTime, renderer) {\r\n    // 更新着色器中的 uTime\r\n    this.materialSun.uniforms.uTime.value = elapsedTime;\r\n    this.materialnoise.uniforms.uTime.value = elapsedTime;\r\n\r\n    // 更新 cubeCamera\r\n    this.cubeCamera.update(renderer, this.textureScene);\r\n\r\n    // 设置 uPerlin 为渲染目标的纹理\r\n    this.materialSun.uniforms.uPerlin.value = this.cubeRenderTarget.texture;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,eAAe,MAAMC,GAAG,CAAC;EACvBC,WAAWA,CAACC,QAAQ,GAAC;IAACC,CAAC,EAAC,CAAC;IAACC,CAAC,EAAC,CAAC;IAACC,CAAC,EAAC;EAAC,CAAC,EAAE;IAClC;IACA,IAAI,CAACC,KAAK,GAAG,IAAIP,KAAK,CAACQ,KAAK,CAAC,CAAC;;IAE9B;IACA,MAAMC,QAAQ,GAAG,IAAIT,KAAK,CAACU,cAAc,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC;;IAEtD;IACA,MAAMC,WAAW,GAAG,IAAIX,KAAK,CAACY,cAAc,CAAC;MAC3CC,YAAY,EAAE,IAAI,CAACC,gBAAgB,CAAC,CAAC;MACrCC,cAAc,EAAE,IAAI,CAACC,kBAAkB,CAAC,CAAC;MACzCC,IAAI,EAAEjB,KAAK,CAACkB,UAAU;MACtBC,QAAQ,EAAE;QACRC,KAAK,EAAE;UAAEC,KAAK,EAAE;QAAE,CAAC;QACnBC,OAAO,EAAE;UAAED,KAAK,EAAE;QAAK;MACzB;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACpB,GAAG,GAAG,IAAID,KAAK,CAACuB,IAAI,CAACd,QAAQ,EAAEE,WAAW,CAAC;IAChD,IAAI,CAACV,GAAG,CAACE,QAAQ,CAACqB,GAAG,CAACrB,QAAQ,CAACC,CAAC,EAAED,QAAQ,CAACE,CAAC,EAAEF,QAAQ,CAACG,CAAC,CAAC;IACzD,IAAI,CAACC,KAAK,CAACkB,GAAG,CAAC,IAAI,CAACxB,GAAG,CAAC;EAC1B;;EAEA;EACAa,gBAAgBA,CAAA,EAAG;IACjB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAE,kBAAkBA,CAAA,EAAG;IACnB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAU,MAAMA,CAACC,WAAW,EAAEC,QAAQ,EAAE;IAC5B;IACA,IAAI,CAACjB,WAAW,CAACQ,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGM,WAAW;IACnD,IAAI,CAACE,aAAa,CAACV,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGM,WAAW;;IAErD;IACA,IAAI,CAACG,UAAU,CAACJ,MAAM,CAACE,QAAQ,EAAE,IAAI,CAACG,YAAY,CAAC;;IAEnD;IACA,IAAI,CAACpB,WAAW,CAACQ,QAAQ,CAACG,OAAO,CAACD,KAAK,GAAG,IAAI,CAACW,gBAAgB,CAACC,OAAO;EACzE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
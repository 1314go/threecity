{"ast":null,"code":"// Sun.js\nimport * as THREE from 'three';\nimport camera from '../camera';\nexport default class Sun {\n  constructor(position = {\n    x: 0,\n    y: 0,\n    z: 0\n  }) {\n    // 创建太阳的主场景\n    this.scene = new THREE.Scene();\n\n    // 创建几何体\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\n\n    // 创建主太阳材质\n    const materialSun = new THREE.ShaderMaterial({\n      vertexShader: this.sunVertexTexture(),\n      fragmentShader: this.sunFragmentTexture(),\n      side: THREE.DoubleSide,\n      uniforms: {\n        uTime: {\n          value: 0\n        },\n        uPerlin: {\n          value: null\n        },\n        cameraPosition: {\n          value: new THREE.Vector3()\n        }\n      }\n    });\n\n    // 创建太阳网格并添加到场景中\n    this.Sun = new THREE.Mesh(geometry, materialSun);\n    this.Sun.position.set(position.x, position.y, position.z);\n    this.scene.add(this.Sun);\n\n    // 创建噪声球体的几何体和材质\n    const noiseGeo = new THREE.SphereGeometry(2.0, 32, 32);\n    const materialnoise = new THREE.ShaderMaterial({\n      vertexShader: this.sunNoiseVertexShader(),\n      fragmentShader: this.sunNoiseFragmentShader(),\n      side: THREE.DoubleSide,\n      uniforms: {\n        uTime: {\n          value: 0\n        }\n      }\n    });\n\n    // 创建噪声球体\n    this.noiseSun = new THREE.Mesh(noiseGeo, materialnoise);\n    this.noiseSun.position.set(position.x, position.y, position.z);\n\n    // 创建纹理生成场景\n    this.textureScene = new THREE.Scene();\n\n    // 添加噪声球体和 cubeCamera 到纹理生成场景\n    this.textureScene.add(this.noiseSun);\n\n    // 创建立方体渲染目标和立方体相机\n    this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128, {\n      generateMipmaps: true,\n      minFilter: THREE.LinearMipmapLinearFilter\n    });\n    this.cubeCamera = new THREE.CubeCamera(0.1, 1000, this.cubeRenderTarget);\n    this.cubeCamera.position.copy(this.noiseSun.position);\n    this.textureScene.add(this.cubeCamera);\n\n    // 保存材质和场景，供外部访问\n    this.materialSun = materialSun;\n    this.materialnoise = materialnoise;\n  }\n\n  // 定义太阳的顶点着色器\n  sunVertexTexture() {\n    return `\n    uniform float uTime;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    // 旋转矩阵\n    mat2 rotate(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    void main()\n    {\n        // uv坐标\n        vUv = uv;\n        // 顶点法线\n        vNormal = normal;\n        // 世界坐标系\n        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n        // 顶点到相机的向量\n        eyeVector = normalize(worldPosition.xyz - cameraPosition);\n\n        // 分别求围绕各个轴所进行的顶点旋转\n        float t = uTime * 0.03;\n        mat2 rot = rotate(t);\n\n        vec3 p0 = position;\n        p0.yz = rot * p0.yz;\n        vLayer0 = p0;\n\n        mat2 rot1 = rotate(t + 10.0);\n        vec3 p1 = position;\n        p1.xz = rot1 * p1.xz;\n        vLayer1 = p1;\n\n        mat2 rot2 = rotate(t + 30.0);\n        vec3 p2 = position;\n        p2.xy = rot2 * p2.xy;\n        vLayer2 = p2;\n\n        vPosition = position;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义太阳的片段着色器\n  sunFragmentTexture() {\n    return `\n    uniform float uTime;\n    uniform samplerCube uPerlin;\n    uniform vec3 cameraPosition;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    const float PI = 3.14159265359;\n\n    vec3 brightnessToColor(float b){\n      b *= 0.25;\n      return (vec3(b, b * b, b * b * b * b) / 0.25) * 0.7;\n    }\n\n    // 将各个图层的纹理叠加整合\n    float sun(){\n      float sum = 0.0;\n      sum += textureCube(uPerlin, vLayer0).r;\n      sum += textureCube(uPerlin, vLayer1).r;\n      sum += textureCube(uPerlin, vLayer2).r;\n      sum *= 0.40;\n      return sum;\n    }\n\n    // 菲涅耳计算\n    float Fresnel(vec3 eyeVector, vec3 worldNormal){\n        return pow(1.0 - dot(eyeVector, worldNormal), 3.0);\n    }\n\n    void main()\n    {\n      // 获取纹理\n      float brightness = sun();\n      // 增加对比度\n      brightness = brightness * 4.0 + 1.0;\n      // 菲涅耳计算模拟反射和折射的光照\n      float fres = Fresnel(eyeVector, normalize(vNormal));\n      brightness += fres;\n      // 获取太阳的颜色\n      vec3 color = brightnessToColor(brightness);\n      gl_FragColor = vec4(color, 1.0);\n    }`;\n  }\n\n  // 定义噪声顶点着色器\n  sunNoiseVertexShader() {\n    return `\n    varying vec3 vPosition;\n    void main()\n    {\n        vPosition = position;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义噪声片段着色器\n  sunNoiseFragmentShader() {\n    return `\n    precision highp float;\n\n    // Simplex 3D Noise \n    // 作者：Ian McEwan, Ashima Arts\n    // 许可证：公共领域（Public Domain）\n    vec3 mod289(vec3 x) { return x - floor(x / 289.0) * 289.0; }\n    vec4 mod289(vec4 x) { return x - floor(x / 289.0) * 289.0; }\n    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n    float snoise(vec3 v) { \n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n      // First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n      // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n\n      // x0 = x0 - 0. + 0.0 * C \n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0 * C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy;      // -1.0 + 3.0 * C.x = -0.5\n\n      // Permutations\n      i = mod289(i); \n      vec4 p = permute( permute( permute( \n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n      // Gradients\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n\n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  // mod(p,7*7)\n\n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n\n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n\n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n\n      // Normalise gradients\n      vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n\n      // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), \n          dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4(dot(p0,x0), dot(p1,x1), \n          dot(p2,x2), dot(p3,x3) ) );\n    }\n\n    // 分形布朗运动（fbm）函数\n    float fbm(vec3 p) {\n        float sum = 0.0;\n        float amp = 0.5;\n        for (int i = 0; i < 5; i++) {\n            sum += amp * snoise(p);\n            p *= 2.0;\n            amp *= 0.5;\n        }\n        return sum;\n    }\n\n    // 声明外部传入的变量\n    uniform float uTime;\n    varying vec3 vPosition;\n\n    void main() {\n        float radius = 2.0;\n        vec3 p = normalize(vPosition) * radius;\n        p += vec3(0.0, 0.0, uTime * 0.1);\n        float sunNoise = fbm(p);\n        sunNoise = pow(sunNoise * 0.5 + 0.5, 2.0);\n        vec3 baseColor = mix(vec3(1.0, 0.6, 0.0), vec3(1.0, 1.0, 0.0), sunNoise);\n        gl_FragColor = vec4(baseColor, 1.0);\n    }`;\n  }\n\n  // 更新函数，在动画循环中调用\n  update(elapsedTime, renderer, camera) {\n    // 更新着色器中的 uTime\n    this.materialSun.uniforms.uTime.value = elapsedTime;\n    this.materialnoise.uniforms.uTime.value = elapsedTime;\n\n    // 更新 cubeCamera\n    this.cubeCamera.position.copy(this.noiseSun.position);\n    this.cubeCamera.update(renderer, this.textureScene);\n\n    // 更新 uPerlin 纹理\n    this.materialSun.uniforms.uPerlin.value = this.cubeRenderTarget.texture;\n\n    // 更新 cameraPosition\n    this.materialSun.uniforms.cameraPosition.value.copy(camera.position);\n  }\n}","map":{"version":3,"names":["THREE","camera","Sun","constructor","position","x","y","z","scene","Scene","geometry","SphereGeometry","materialSun","ShaderMaterial","vertexShader","sunVertexTexture","fragmentShader","sunFragmentTexture","side","DoubleSide","uniforms","uTime","value","uPerlin","cameraPosition","Vector3","Mesh","set","add","noiseGeo","materialnoise","sunNoiseVertexShader","sunNoiseFragmentShader","noiseSun","textureScene","cubeRenderTarget","WebGLCubeRenderTarget","generateMipmaps","minFilter","LinearMipmapLinearFilter","cubeCamera","CubeCamera","copy","update","elapsedTime","renderer","texture"],"sources":["E:/three.js/three.js-demo/three-city/city/src/three/mesh/sun.js"],"sourcesContent":["// Sun.js\r\nimport * as THREE from 'three';\r\nimport camera from '../camera';\r\nexport default class Sun {\r\n  constructor(position = { x: 0, y: 0, z: 0 }) {\r\n    // 创建太阳的主场景\r\n    this.scene = new THREE.Scene();\r\n\r\n    // 创建几何体\r\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\r\n\r\n    // 创建主太阳材质\r\n    const materialSun = new THREE.ShaderMaterial({\r\n      vertexShader: this.sunVertexTexture(),\r\n      fragmentShader: this.sunFragmentTexture(),\r\n      side: THREE.DoubleSide,\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n        uPerlin: { value: null },\r\n        cameraPosition: { value: new THREE.Vector3() },\r\n      },\r\n    });\r\n\r\n    // 创建太阳网格并添加到场景中\r\n    this.Sun = new THREE.Mesh(geometry, materialSun);\r\n    this.Sun.position.set(position.x, position.y, position.z);\r\n    this.scene.add(this.Sun);\r\n\r\n    // 创建噪声球体的几何体和材质\r\n    const noiseGeo = new THREE.SphereGeometry(2.0, 32, 32);\r\n    const materialnoise = new THREE.ShaderMaterial({\r\n      vertexShader: this.sunNoiseVertexShader(),\r\n      fragmentShader: this.sunNoiseFragmentShader(),\r\n      side: THREE.DoubleSide,\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n      },\r\n    });\r\n\r\n    // 创建噪声球体\r\n    this.noiseSun = new THREE.Mesh(noiseGeo, materialnoise);\r\n    this.noiseSun.position.set(position.x, position.y, position.z);\r\n\r\n    // 创建纹理生成场景\r\n    this.textureScene = new THREE.Scene();\r\n\r\n    // 添加噪声球体和 cubeCamera 到纹理生成场景\r\n    this.textureScene.add(this.noiseSun);\r\n\r\n    // 创建立方体渲染目标和立方体相机\r\n    this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128, {\r\n      generateMipmaps: true,\r\n      minFilter: THREE.LinearMipmapLinearFilter,\r\n    });\r\n    this.cubeCamera = new THREE.CubeCamera(0.1, 1000, this.cubeRenderTarget);\r\n    this.cubeCamera.position.copy(this.noiseSun.position);\r\n    this.textureScene.add(this.cubeCamera);\r\n\r\n    // 保存材质和场景，供外部访问\r\n    this.materialSun = materialSun;\r\n    this.materialnoise = materialnoise;\r\n  }\r\n\r\n  // 定义太阳的顶点着色器\r\n  sunVertexTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    varying vec2 vUv;\r\n    varying vec3 vPosition;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    varying vec3 vNormal;\r\n\r\n    // 旋转矩阵\r\n    mat2 rotate(float a){\r\n        float s = sin(a);\r\n        float c = cos(a);\r\n        return mat2(c, -s, s, c);\r\n    }\r\n\r\n    void main()\r\n    {\r\n        // uv坐标\r\n        vUv = uv;\r\n        // 顶点法线\r\n        vNormal = normal;\r\n        // 世界坐标系\r\n        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n        // 顶点到相机的向量\r\n        eyeVector = normalize(worldPosition.xyz - cameraPosition);\r\n\r\n        // 分别求围绕各个轴所进行的顶点旋转\r\n        float t = uTime * 0.03;\r\n        mat2 rot = rotate(t);\r\n\r\n        vec3 p0 = position;\r\n        p0.yz = rot * p0.yz;\r\n        vLayer0 = p0;\r\n\r\n        mat2 rot1 = rotate(t + 10.0);\r\n        vec3 p1 = position;\r\n        p1.xz = rot1 * p1.xz;\r\n        vLayer1 = p1;\r\n\r\n        mat2 rot2 = rotate(t + 30.0);\r\n        vec3 p2 = position;\r\n        p2.xy = rot2 * p2.xy;\r\n        vLayer2 = p2;\r\n\r\n        vPosition = position;\r\n\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义太阳的片段着色器\r\n  sunFragmentTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    uniform samplerCube uPerlin;\r\n    uniform vec3 cameraPosition;\r\n    varying vec2 vUv;\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    const float PI = 3.14159265359;\r\n\r\n    vec3 brightnessToColor(float b){\r\n      b *= 0.25;\r\n      return (vec3(b, b * b, b * b * b * b) / 0.25) * 0.7;\r\n    }\r\n\r\n    // 将各个图层的纹理叠加整合\r\n    float sun(){\r\n      float sum = 0.0;\r\n      sum += textureCube(uPerlin, vLayer0).r;\r\n      sum += textureCube(uPerlin, vLayer1).r;\r\n      sum += textureCube(uPerlin, vLayer2).r;\r\n      sum *= 0.40;\r\n      return sum;\r\n    }\r\n\r\n    // 菲涅耳计算\r\n    float Fresnel(vec3 eyeVector, vec3 worldNormal){\r\n        return pow(1.0 - dot(eyeVector, worldNormal), 3.0);\r\n    }\r\n\r\n    void main()\r\n    {\r\n      // 获取纹理\r\n      float brightness = sun();\r\n      // 增加对比度\r\n      brightness = brightness * 4.0 + 1.0;\r\n      // 菲涅耳计算模拟反射和折射的光照\r\n      float fres = Fresnel(eyeVector, normalize(vNormal));\r\n      brightness += fres;\r\n      // 获取太阳的颜色\r\n      vec3 color = brightnessToColor(brightness);\r\n      gl_FragColor = vec4(color, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义噪声顶点着色器\r\n  sunNoiseVertexShader() {\r\n    return `\r\n    varying vec3 vPosition;\r\n    void main()\r\n    {\r\n        vPosition = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义噪声片段着色器\r\n  sunNoiseFragmentShader() {\r\n    return `\r\n    precision highp float;\r\n\r\n    // Simplex 3D Noise \r\n    // 作者：Ian McEwan, Ashima Arts\r\n    // 许可证：公共领域（Public Domain）\r\n    vec3 mod289(vec3 x) { return x - floor(x / 289.0) * 289.0; }\r\n    vec4 mod289(vec4 x) { return x - floor(x / 289.0) * 289.0; }\r\n    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\r\n    float snoise(vec3 v) { \r\n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n      // First corner\r\n      vec3 i  = floor(v + dot(v, C.yyy) );\r\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n      // Other corners\r\n      vec3 g = step(x0.yzx, x0.xyz);\r\n      vec3 l = 1.0 - g;\r\n      vec3 i1 = min( g.xyz, l.zxy );\r\n      vec3 i2 = max( g.xyz, l.zxy );\r\n\r\n      // x0 = x0 - 0. + 0.0 * C \r\n      vec3 x1 = x0 - i1 + C.xxx;\r\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0 * C.x = 1/3 = C.y\r\n      vec3 x3 = x0 - D.yyy;      // -1.0 + 3.0 * C.x = -0.5\r\n\r\n      // Permutations\r\n      i = mod289(i); \r\n      vec4 p = permute( permute( permute( \r\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n      // Gradients\r\n      float n_ = 0.142857142857; // 1.0/7.0\r\n      vec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  // mod(p,7*7)\r\n\r\n      vec4 x_ = floor(j * ns.z);\r\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n      vec4 x = x_ *ns.x + ns.yyyy;\r\n      vec4 y = y_ *ns.x + ns.yyyy;\r\n      vec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n      vec4 b0 = vec4( x.xy, y.xy );\r\n      vec4 b1 = vec4( x.zw, y.zw );\r\n\r\n      vec4 s0 = floor(b0)*2.0 + 1.0;\r\n      vec4 s1 = floor(b1)*2.0 + 1.0;\r\n      vec4 sh = -step(h, vec4(0.0));\r\n\r\n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n      vec3 p0 = vec3(a0.xy,h.x);\r\n      vec3 p1 = vec3(a0.zw,h.y);\r\n      vec3 p2 = vec3(a1.xy,h.z);\r\n      vec3 p3 = vec3(a1.zw,h.w);\r\n\r\n      // Normalise gradients\r\n      vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\r\n      p0 *= norm.x;\r\n      p1 *= norm.y;\r\n      p2 *= norm.z;\r\n      p3 *= norm.w;\r\n\r\n      // Mix final noise value\r\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), \r\n          dot(x2,x2), dot(x3,x3)), 0.0);\r\n      m = m * m;\r\n      return 42.0 * dot( m*m, vec4(dot(p0,x0), dot(p1,x1), \r\n          dot(p2,x2), dot(p3,x3) ) );\r\n    }\r\n\r\n    // 分形布朗运动（fbm）函数\r\n    float fbm(vec3 p) {\r\n        float sum = 0.0;\r\n        float amp = 0.5;\r\n        for (int i = 0; i < 5; i++) {\r\n            sum += amp * snoise(p);\r\n            p *= 2.0;\r\n            amp *= 0.5;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    // 声明外部传入的变量\r\n    uniform float uTime;\r\n    varying vec3 vPosition;\r\n\r\n    void main() {\r\n        float radius = 2.0;\r\n        vec3 p = normalize(vPosition) * radius;\r\n        p += vec3(0.0, 0.0, uTime * 0.1);\r\n        float sunNoise = fbm(p);\r\n        sunNoise = pow(sunNoise * 0.5 + 0.5, 2.0);\r\n        vec3 baseColor = mix(vec3(1.0, 0.6, 0.0), vec3(1.0, 1.0, 0.0), sunNoise);\r\n        gl_FragColor = vec4(baseColor, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 更新函数，在动画循环中调用\r\n  update(elapsedTime, renderer, camera) {\r\n    // 更新着色器中的 uTime\r\n    this.materialSun.uniforms.uTime.value = elapsedTime;\r\n    this.materialnoise.uniforms.uTime.value = elapsedTime;\r\n\r\n    // 更新 cubeCamera\r\n    this.cubeCamera.position.copy(this.noiseSun.position);\r\n    this.cubeCamera.update(renderer, this.textureScene);\r\n\r\n    // 更新 uPerlin 纹理\r\n    this.materialSun.uniforms.uPerlin.value = this.cubeRenderTarget.texture;\r\n\r\n    // 更新 cameraPosition\r\n    this.materialSun.uniforms.cameraPosition.value.copy(camera.position);\r\n  }\r\n}\r\n"],"mappings":"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A,MAAM;EACJ;;EAEA;EACAE,kBAAkBA,CAAA,EAAG;IACnB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAc,oBAAoBA,CAAA,EAAG;IACrB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAC,sBAAsBA,CAAA,EAAG;IACvB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAW,MAAMA,CAACC,WAAW,EAAEC,QAAQ,EAAE5C,MAAM,EAAE;IACpC;IACA,IAAI,CAACW,WAAW,CAACQ,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGsB,WAAW;IACnD,IAAI,CAACd,aAAa,CAACV,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGsB,WAAW;;IAErD;IACA,IAAI,CAACJ,UAAU,CAACpC,QAAQ,CAACsC,IAAI,CAAC,IAAI,CAACT,QAAQ,CAAC7B,QAAQ,CAAC;IACrD,IAAI,CAACoC,UAAU,CAACG,MAAM,CAACE,QAAQ,EAAE,IAAI,CAACX,YAAY,CAAC;;IAEnD;IACA,IAAI,CAACtB,WAAW,CAACQ,QAAQ,CAACG,OAAO,CAACD,KAAK,GAAG,IAAI,CAACa,gBAAgB,CAACW,OAAO;;IAEvE;IACA,IAAI,CAAClC,WAAW,CAACQ,QAAQ,CAACI,cAAc,CAACF,KAAK,CAACoB,IAAI,CAACzC,MAAM,CAACG,QAAQ,CAAC;EACtE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
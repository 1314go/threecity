{"ast":null,"code":"// Sun.js\nimport * as THREE from 'three';\nexport default class Sun {\n  constructor(position = {\n    x: 0,\n    y: 0,\n    z: 0\n  }) {\n    // 创建太阳的主场景\n    this.scene = new THREE.Scene();\n\n    // 创建几何体\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\n\n    // 创建主太阳材质\n    const materialSun = new THREE.ShaderMaterial({\n      vertexShader: this.sunVertexTexture(),\n      fragmentShader: this.sunFragmentTexture(),\n      side: THREE.DoubleSide,\n      uniforms: {\n        uTime: {\n          value: 0\n        },\n        uPerlin: {\n          value: null\n        }\n      }\n    });\n\n    // 创建太阳网格并添加到场景中\n    this.Sun = new THREE.Mesh(geometry, materialSun);\n    this.Sun.position.set(position.x, position.y, position.z);\n    this.scene.add(this.Sun);\n\n    //     // 创建辅助场景用于生成噪声纹理\n    //     this.scene2 = new THREE.Scene();\n\n    //     // 创建噪声球体的几何体和材质\n    //     const noiseGeo = new THREE.SphereGeometry(2.0, 32, 32);\n    //     const materialnoise = new THREE.ShaderMaterial({\n    //       vertexShader: this.sunVertexShader(),\n    //       fragmentShader: this.sunFragmentShader(),\n    //       side: THREE.DoubleSide,\n    //       uniforms: {\n    //         uTime: { value: 0 }\n    //       }\n    //     });\n\n    //     // 创建噪声球体并添加到辅助场景中\n    //     this.noiseSun = new THREE.Mesh(noiseGeo, materialnoise);\n    //     //this.noiseSun.scale.set(position.x, position.y, position.z);\n    //     this.noiseSun.position.set(position.x, position.y, position.z);\n    //     //this.scene2.add(this.noiseSun);\n\n    //     // 创建立方体渲染目标和立方体相机\n    //     this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128, {\n    //       generateMipmaps: true,\n    //       minFilter: THREE.LinearMipmapLinearFilter\n    //     });\n    //     this.cubeCamera = new THREE.CubeCamera(1, 100000, this.cubeRenderTarget);\n    //     this.cubeCamera.position.copy(this.noiseSun.position);\n    //     //this.scene2.add(this.cubeCamera);\n    // // 创建纹理生成场景\n    //         this.textureScene = new THREE.Scene();\n\n    // // 添加噪声球体和 cubeCamera 到纹理生成场景\n    //       this.textureScene.add(this.noiseSun);\n    //       this.textureScene.add(this.cubeCamera);\n\n    // // 创建太阳外部光晕\n    // const sunRundGeo = new THREE.SphereGeometry(4.0, 32, 32);\n    // const rundSun = new THREE.ShaderMaterial({\n    //   vertexShader: this.sunRundVertexTexture(),\n    //   fragmentShader: this.sunRundFragmentTexture(),\n    //   side: THREE.BackSide,\n    //   uniforms: {\n    //     uTime: { value: 0 },\n    //     uPerlin: { value: null }\n    //   }\n    // });\n    // this.texturedSunRund = new THREE.Mesh(sunRundGeo, rundSun);\n    // this.texturedSunRund.position.set(position.x, position.y, position.z);\n    // this.scene.add(this.texturedSunRund);\n\n    // // 保存材质和场景，供外部访问\n    // this.materialSun = materialSun;\n    // this.materialnoise = materialnoise;\n  }\n\n  // 定义太阳的顶点着色器\n  sunVertexTexture() {\n    return `\n    uniform float uTime;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    //旋转矩阵\n    mat2 rotate(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c,-s,s,c);\n    } \n\n    void main()\n    {\n        // uv坐标\n        vUv = uv;\n        // 顶点法线\n        vNormal = normal;\n        // 世界坐标系\n        vec4 WorldPosition = modelMatrix * vec4 (position,1.0);\n        // 顶点到相机的向量\n        eyeVector = normalize(WorldPosition.xyz - cameraPosition);\n\n        // 分别求围绕各个轴所进行的顶点旋转\n        float t = uTime * 0.03;\n        mat2 rot = rotate(t);\n\n        vec3 p0 = position;\n        p0.yz = rot * p0.yz;\n        vLayer0 = p0;\n\n        mat2 rot1 = rotate(t+10.0);\n        vec3 p1 = position;\n        p1.xz = rot1 * p1.xz;\n        vLayer1 = p1;\n\n        mat2 rot2 = rotate(t+30.0);\n        vec3 p2 = position;\n        p2.xy = rot2 * p2.xy;\n        vLayer2 = p2; \n\n        vPosition = position;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义太阳的片段着色器\n  sunFragmentTexture() {\n    return `\n    uniform float uTime;\n    varying vec2 vUv;\n    uniform samplerCube uPerlin;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    const float PI = 3.14159265359;\n\n    vec3 brightnessToColor (float b){\n      b *=0.25;\n      return (vec3(b, b*b, b*b*b*b)/0.25)*0.7;\n    }\n\n    // 将各个图层的纹理叠加整合\n    float sun(){\n      float sum = 0.0;\n      sum +=textureCube(uPerlin,vLayer0).r;\n      sum +=textureCube(uPerlin,vLayer1).r;\n      sum +=textureCube(uPerlin,vLayer2).r;\n      sum *=0.40;\n      return sum;\n    }\n\n    // 菲涅耳计算\n    float Fresnel(vec3 eyeVector,vec3 worldNormal){\n        return pow(1.3 + dot(eyeVector,worldNormal),4.0);\n    }\n\n    void main()\n    {\n      // 获取纹理\n      float brightness = sun();\n      // 增加对比度\n      brightness = brightness*4.0+1.0;\n      // 菲涅耳计算模拟反射和折射的光照\n      float fres = Fresnel(eyeVector,vNormal);\n      brightness += fres;\n      // 获取太阳的颜色\n      vec3 color = brightnessToColor(brightness); \n      gl_FragColor = vec4(color,1.0);\n    }`;\n  }\n\n  // 定义噪声顶点着色器\n  sunVertexShader() {\n    return `\n    varying vec3 vPosition;\n    void main()\n    {\n        vPosition = position;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义噪声片段着色器\n  sunFragmentShader() {\n    return `\n    precision highp float;\n\n    // 修改后的 hash 函数，返回 vec2 类型\n    vec2 hash(vec2 p)\n    {\n        p = vec2(\n            dot(p, vec2(127.1, 311.7)),\n            dot(p, vec2(269.5, 183.3))\n        );\n        return fract(sin(p) * 43758.5453);\n    }\n\n    // 噪声函数，使用新的 hash 函数\n    float noise(vec2 p)\n    {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2 i = floor(p + (p.x + p.y) * K1);\n        vec2 a = p - i + (i.x + i.y) * K2;\n\n        vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0 * K2;\n\n        // 计算三角形顶点的权重\n        vec3 h = max(0.5 - vec3(\n            dot(a, a), \n            dot(b, b), \n            dot(c, c)\n        ), 0.0);\n\n        // 计算噪声贡献\n        vec3 n = h * h * h * h * vec3(\n            dot(a, hash(i + vec2(0.0, 0.0))),\n            dot(b, hash(i + o)),\n            dot(c, hash(i + vec2(1.0, 1.0)))\n        );\n\n        return dot(n, vec3(70.0));\n    }\n\n    // 分形布朗运动（fbm）函数\n    float fbm(vec2 p)\n    {\n        float sum = 0.0;\n        float amp = 1.0;\n        float scale = 1.0;\n        for (int i = 0; i < 9; i++)\n        {\n            sum += noise(p * scale) * amp;\n            p += 100.0;\n            amp *= 0.8;\n            scale *= 2.0;\n        }\n        return sum;\n    }\n\n    // 声明外部传入的变量\n    uniform float uTime;\n    varying vec3 vPosition;\n\n    void main()\n    {\n        vec2 p = vPosition.xy * 0.7;\n        float sunNoise = fbm(p + uTime * 0.1);\n        gl_FragColor = vec4(vec3(sunNoise * 0.8), 1.0);\n    }`;\n  }\n\n  // 定义太阳光晕的顶点着色器\n  sunRundVertexTexture() {\n    return `\n    uniform float uTime;\n    varying vec3 vPosition;\n\n    void main()\n    {\n        vPosition = position;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义太阳光晕的片段着色器\n  sunRundFragmentTexture() {\n    return `\n    varying vec3 vPosition;\n    // 太阳色构建\n    vec3 brightnessToColor (float b){\n      b *=0.25;\n      return (vec3(b, b*b, b*b*b*b)/0.25);\n    }\n\n    void main()\n    {\n      float d = mix(0.25, 0.0, vPosition.z);\n      d = pow(d, 3.0);\n      vec3 color = brightnessToColor(d);\n      gl_FragColor = vec4(vec3(color), 1.0);\n    }`;\n  }\n\n  // 更新函数，在动画循环中调用\n  update(elapsedTime, renderer) {\n    // 更新着色器中的 uTime\n    this.materialSun.uniforms.uTime.value = elapsedTime;\n    this.materialnoise.uniforms.uTime.value = elapsedTime;\n\n    // 更新 cubeCamera\n    this.cubeCamera.update(renderer, this.textureScene);\n\n    // 设置 uPerlin 为渲染目标的纹理\n    this.materialSun.uniforms.uPerlin.value = this.cubeRenderTarget.texture;\n  }\n}","map":{"version":3,"names":["THREE","Sun","constructor","position","x","y","z","scene","Scene","geometry","SphereGeometry","materialSun","ShaderMaterial","vertexShader","sunVertexTexture","fragmentShader","sunFragmentTexture","side","DoubleSide","uniforms","uTime","value","uPerlin","Mesh","set","add","sunVertexShader","sunFragmentShader","sunRundVertexTexture","sunRundFragmentTexture","update","elapsedTime","renderer","materialnoise","cubeCamera","textureScene","cubeRenderTarget","texture"],"sources":["E:/three.js/three.js-demo/three-city/city/src/three/mesh/sun.js"],"sourcesContent":["// Sun.js\r\nimport * as THREE from 'three';\r\n\r\nexport default class Sun {\r\n  constructor(position={x:0,y:0,z:0}) {\r\n    // 创建太阳的主场景\r\n    this.scene = new THREE.Scene();\r\n\r\n    // 创建几何体\r\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\r\n\r\n    // 创建主太阳材质\r\n    const materialSun = new THREE.ShaderMaterial({\r\n      vertexShader: this.sunVertexTexture(),\r\n      fragmentShader: this.sunFragmentTexture(),\r\n      side: THREE.DoubleSide,\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n        uPerlin: { value: null }\r\n      }\r\n    });\r\n\r\n    // 创建太阳网格并添加到场景中\r\n    this.Sun = new THREE.Mesh(geometry, materialSun);\r\n    this.Sun.position.set(position.x, position.y, position.z);\r\n    this.scene.add(this.Sun);\r\n\r\n//     // 创建辅助场景用于生成噪声纹理\r\n//     this.scene2 = new THREE.Scene();\r\n\r\n//     // 创建噪声球体的几何体和材质\r\n//     const noiseGeo = new THREE.SphereGeometry(2.0, 32, 32);\r\n//     const materialnoise = new THREE.ShaderMaterial({\r\n//       vertexShader: this.sunVertexShader(),\r\n//       fragmentShader: this.sunFragmentShader(),\r\n//       side: THREE.DoubleSide,\r\n//       uniforms: {\r\n//         uTime: { value: 0 }\r\n//       }\r\n//     });\r\n\r\n//     // 创建噪声球体并添加到辅助场景中\r\n//     this.noiseSun = new THREE.Mesh(noiseGeo, materialnoise);\r\n//     //this.noiseSun.scale.set(position.x, position.y, position.z);\r\n//     this.noiseSun.position.set(position.x, position.y, position.z);\r\n//     //this.scene2.add(this.noiseSun);\r\n\r\n//     // 创建立方体渲染目标和立方体相机\r\n//     this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128, {\r\n//       generateMipmaps: true,\r\n//       minFilter: THREE.LinearMipmapLinearFilter\r\n//     });\r\n//     this.cubeCamera = new THREE.CubeCamera(1, 100000, this.cubeRenderTarget);\r\n//     this.cubeCamera.position.copy(this.noiseSun.position);\r\n//     //this.scene2.add(this.cubeCamera);\r\n// // 创建纹理生成场景\r\n//         this.textureScene = new THREE.Scene();\r\n\r\n// // 添加噪声球体和 cubeCamera 到纹理生成场景\r\n//       this.textureScene.add(this.noiseSun);\r\n//       this.textureScene.add(this.cubeCamera);\r\n\r\n    // // 创建太阳外部光晕\r\n    // const sunRundGeo = new THREE.SphereGeometry(4.0, 32, 32);\r\n    // const rundSun = new THREE.ShaderMaterial({\r\n    //   vertexShader: this.sunRundVertexTexture(),\r\n    //   fragmentShader: this.sunRundFragmentTexture(),\r\n    //   side: THREE.BackSide,\r\n    //   uniforms: {\r\n    //     uTime: { value: 0 },\r\n    //     uPerlin: { value: null }\r\n    //   }\r\n    // });\r\n    // this.texturedSunRund = new THREE.Mesh(sunRundGeo, rundSun);\r\n    // this.texturedSunRund.position.set(position.x, position.y, position.z);\r\n    // this.scene.add(this.texturedSunRund);\r\n\r\n    // // 保存材质和场景，供外部访问\r\n    // this.materialSun = materialSun;\r\n    // this.materialnoise = materialnoise;\r\n  }\r\n\r\n  // 定义太阳的顶点着色器\r\n  sunVertexTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    varying vec2 vUv;\r\n    varying vec3 vPosition;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    varying vec3 vNormal;\r\n\r\n    //旋转矩阵\r\n    mat2 rotate(float a){\r\n        float s = sin(a);\r\n        float c = cos(a);\r\n        return mat2(c,-s,s,c);\r\n    } \r\n\r\n    void main()\r\n    {\r\n        // uv坐标\r\n        vUv = uv;\r\n        // 顶点法线\r\n        vNormal = normal;\r\n        // 世界坐标系\r\n        vec4 WorldPosition = modelMatrix * vec4 (position,1.0);\r\n        // 顶点到相机的向量\r\n        eyeVector = normalize(WorldPosition.xyz - cameraPosition);\r\n\r\n        // 分别求围绕各个轴所进行的顶点旋转\r\n        float t = uTime * 0.03;\r\n        mat2 rot = rotate(t);\r\n\r\n        vec3 p0 = position;\r\n        p0.yz = rot * p0.yz;\r\n        vLayer0 = p0;\r\n\r\n        mat2 rot1 = rotate(t+10.0);\r\n        vec3 p1 = position;\r\n        p1.xz = rot1 * p1.xz;\r\n        vLayer1 = p1;\r\n\r\n        mat2 rot2 = rotate(t+30.0);\r\n        vec3 p2 = position;\r\n        p2.xy = rot2 * p2.xy;\r\n        vLayer2 = p2; \r\n\r\n        vPosition = position;\r\n\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义太阳的片段着色器\r\n  sunFragmentTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    varying vec2 vUv;\r\n    uniform samplerCube uPerlin;\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    const float PI = 3.14159265359;\r\n\r\n    vec3 brightnessToColor (float b){\r\n      b *=0.25;\r\n      return (vec3(b, b*b, b*b*b*b)/0.25)*0.7;\r\n    }\r\n\r\n    // 将各个图层的纹理叠加整合\r\n    float sun(){\r\n      float sum = 0.0;\r\n      sum +=textureCube(uPerlin,vLayer0).r;\r\n      sum +=textureCube(uPerlin,vLayer1).r;\r\n      sum +=textureCube(uPerlin,vLayer2).r;\r\n      sum *=0.40;\r\n      return sum;\r\n    }\r\n\r\n    // 菲涅耳计算\r\n    float Fresnel(vec3 eyeVector,vec3 worldNormal){\r\n        return pow(1.3 + dot(eyeVector,worldNormal),4.0);\r\n    }\r\n\r\n    void main()\r\n    {\r\n      // 获取纹理\r\n      float brightness = sun();\r\n      // 增加对比度\r\n      brightness = brightness*4.0+1.0;\r\n      // 菲涅耳计算模拟反射和折射的光照\r\n      float fres = Fresnel(eyeVector,vNormal);\r\n      brightness += fres;\r\n      // 获取太阳的颜色\r\n      vec3 color = brightnessToColor(brightness); \r\n      gl_FragColor = vec4(color,1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义噪声顶点着色器\r\n  sunVertexShader() {\r\n    return `\r\n    varying vec3 vPosition;\r\n    void main()\r\n    {\r\n        vPosition = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义噪声片段着色器\r\n  sunFragmentShader() {\r\n    return `\r\n    precision highp float;\r\n\r\n    // 修改后的 hash 函数，返回 vec2 类型\r\n    vec2 hash(vec2 p)\r\n    {\r\n        p = vec2(\r\n            dot(p, vec2(127.1, 311.7)),\r\n            dot(p, vec2(269.5, 183.3))\r\n        );\r\n        return fract(sin(p) * 43758.5453);\r\n    }\r\n\r\n    // 噪声函数，使用新的 hash 函数\r\n    float noise(vec2 p)\r\n    {\r\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n        vec2 i = floor(p + (p.x + p.y) * K1);\r\n        vec2 a = p - i + (i.x + i.y) * K2;\r\n\r\n        vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n        vec2 b = a - o + K2;\r\n        vec2 c = a - 1.0 + 2.0 * K2;\r\n\r\n        // 计算三角形顶点的权重\r\n        vec3 h = max(0.5 - vec3(\r\n            dot(a, a), \r\n            dot(b, b), \r\n            dot(c, c)\r\n        ), 0.0);\r\n\r\n        // 计算噪声贡献\r\n        vec3 n = h * h * h * h * vec3(\r\n            dot(a, hash(i + vec2(0.0, 0.0))),\r\n            dot(b, hash(i + o)),\r\n            dot(c, hash(i + vec2(1.0, 1.0)))\r\n        );\r\n\r\n        return dot(n, vec3(70.0));\r\n    }\r\n\r\n    // 分形布朗运动（fbm）函数\r\n    float fbm(vec2 p)\r\n    {\r\n        float sum = 0.0;\r\n        float amp = 1.0;\r\n        float scale = 1.0;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            sum += noise(p * scale) * amp;\r\n            p += 100.0;\r\n            amp *= 0.8;\r\n            scale *= 2.0;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    // 声明外部传入的变量\r\n    uniform float uTime;\r\n    varying vec3 vPosition;\r\n\r\n    void main()\r\n    {\r\n        vec2 p = vPosition.xy * 0.7;\r\n        float sunNoise = fbm(p + uTime * 0.1);\r\n        gl_FragColor = vec4(vec3(sunNoise * 0.8), 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义太阳光晕的顶点着色器\r\n  sunRundVertexTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    varying vec3 vPosition;\r\n\r\n    void main()\r\n    {\r\n        vPosition = position;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义太阳光晕的片段着色器\r\n  sunRundFragmentTexture() {\r\n    return `\r\n    varying vec3 vPosition;\r\n    // 太阳色构建\r\n    vec3 brightnessToColor (float b){\r\n      b *=0.25;\r\n      return (vec3(b, b*b, b*b*b*b)/0.25);\r\n    }\r\n\r\n    void main()\r\n    {\r\n      float d = mix(0.25, 0.0, vPosition.z);\r\n      d = pow(d, 3.0);\r\n      vec3 color = brightnessToColor(d);\r\n      gl_FragColor = vec4(vec3(color), 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 更新函数，在动画循环中调用\r\n  update(elapsedTime, renderer) {\r\n    // 更新着色器中的 uTime\r\n    this.materialSun.uniforms.uTime.value = elapsedTime;\r\n    this.materialnoise.uniforms.uTime.value = elapsedTime;\r\n\r\n    // 更新 cubeCamera\r\n    this.cubeCamera.update(renderer, this.textureScene);\r\n\r\n    // 设置 uPerlin 为渲染目标的纹理\r\n    this.materialSun.uniforms.uPerlin.value = this.cubeRenderTarget.texture;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,eAAe,MAAMC,GAAG,CAAC;EACvBC,WAAWA,CAACC,QAAQ,GAAC;IAACC,CAAC,EAAC,CAAC;IAACC,CAAC,EAAC,CAAC;IAACC,CAAC,EAAC;EAAC,CAAC,EAAE;IAClC;IACA,IAAI,CAACC,KAAK,GAAG,IAAIP,KAAK,CAACQ,KAAK,CAAC,CAAC;;IAE9B;IACA,MAAMC,QAAQ,GAAG,IAAIT,KAAK,CAACU,cAAc,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC;;IAEtD;IACA,MAAMC,WAAW,GAAG,IAAIX,KAAK,CAACY,cAAc,CAAC;MAC3CC,YAAY,EAAE,IAAI,CAACC,gBAAgB,CAAC,CAAC;MACrCC,cAAc,EAAE,IAAI,CAACC,kBAAkB,CAAC,CAAC;MACzCC,IAAI,EAAEjB,KAAK,CAACkB,UAAU;MACtBC,QAAQ,EAAE;QACRC,KAAK,EAAE;UAAEC,KAAK,EAAE;QAAE,CAAC;QACnBC,OAAO,EAAE;UAAED,KAAK,EAAE;QAAK;MACzB;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACpB,GAAG,GAAG,IAAID,KAAK,CAACuB,IAAI,CAACd,QAAQ,EAAEE,WAAW,CAAC;IAChD,IAAI,CAACV,GAAG,CAACE,QAAQ,CAACqB,GAAG,CAACrB,QAAQ,CAACC,CAAC,EAAED,QAAQ,CAACE,CAAC,EAAEF,QAAQ,CAACG,CAAC,CAAC;IACzD,IAAI,CAACC,KAAK,CAACkB,GAAG,CAAC,IAAI,CAACxB,GAAG,CAAC;;IAE5B;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEI;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;EACF;;EAEA;EACAa,gBAAgBA,CAAA,EAAG;IACjB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAE,kBAAkBA,CAAA,EAAG;IACnB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAU,eAAeA,CAAA,EAAG;IAChB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAC,iBAAiBA,CAAA,EAAG;IAClB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAC,oBAAoBA,CAAA,EAAG;IACrB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAC,sBAAsBA,CAAA,EAAG;IACvB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAC,MAAMA,CAACC,WAAW,EAAEC,QAAQ,EAAE;IAC5B;IACA,IAAI,CAACrB,WAAW,CAACQ,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGU,WAAW;IACnD,IAAI,CAACE,aAAa,CAACd,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGU,WAAW;;IAErD;IACA,IAAI,CAACG,UAAU,CAACJ,MAAM,CAACE,QAAQ,EAAE,IAAI,CAACG,YAAY,CAAC;;IAEnD;IACA,IAAI,CAACxB,WAAW,CAACQ,QAAQ,CAACG,OAAO,CAACD,KAAK,GAAG,IAAI,CAACe,gBAAgB,CAACC,OAAO;EACzE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
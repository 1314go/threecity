{"ast":null,"code":"// Sun.js\n\nimport * as THREE from 'three';\nexport default class Sun {\n  constructor(position = {\n    x: 0,\n    y: 0,\n    z: 0\n  }) {\n    // 创建太阳的主场景\n    this.scene = new THREE.Scene();\n\n    // 创建太阳几何体\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\n\n    // 创建主太阳材质\n    this.materialSun = new THREE.ShaderMaterial({\n      vertexShader: this.sunVertexTexture(),\n      fragmentShader: this.sunFragmentTexture(),\n      side: THREE.FrontSide,\n      uniforms: {\n        uTime: {\n          value: 0\n        },\n        uPerlin: {\n          value: null\n        },\n        ucameraPosition: {\n          value: new THREE.Vector3()\n        }\n      }\n    });\n\n    // 创建太阳网格并添加到场景中\n    this.Sun = new THREE.Mesh(geometry, this.materialSun);\n    this.Sun.position.set(position.x, position.y, position.z);\n    this.scene.add(this.Sun);\n\n    // 创建天空球体\n    const skyGeometry = new THREE.SphereGeometry(5000, 32, 32);\n    this.skyMaterial = new THREE.ShaderMaterial({\n      vertexShader: this.skyVertexShader(),\n      fragmentShader: this.skyFragmentShader(),\n      side: THREE.BackSide,\n      uniforms: {\n        sunDirection: {\n          value: new THREE.Vector3()\n        },\n        cameraPos: {\n          value: new THREE.Vector3()\n        },\n        turbidity: {\n          value: 10\n        },\n        rayleigh: {\n          value: 2\n        },\n        mieCoefficient: {\n          value: 0.005\n        },\n        mieDirectionalG: {\n          value: 0.8\n        }\n      }\n    });\n    this.skyMesh = new THREE.Mesh(skyGeometry, this.skyMaterial);\n    this.scene.add(this.skyMesh);\n  }\n\n  // 定义太阳的顶点着色器\n  sunVertexTexture() {\n    return `\n    uniform float uTime;\n    uniform vec3 ucameraPosition;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    varying vec3 vNormal;\n\n    // 旋转矩阵\n    mat2 rotate(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c,-s,s,c);\n    } \n\n    void main()\n    {\n        // uv坐标\n        vUv = uv;\n        // 顶点法线\n        vNormal = normal;\n        // 世界坐标系\n        vec4 WorldPosition = modelMatrix * vec4 (position,1.0);\n        // 顶点到相机的向量\n        eyeVector = normalize(WorldPosition.xyz - ucameraPosition);\n\n        // 分别求围绕各个轴所进行的顶点旋转\n        float t = uTime * 0.03;\n        mat2 rot = rotate(t);\n\n        vec3 p0 = position;\n        p0.yz = rot * p0.yz;\n        vLayer0 = p0;\n\n        mat2 rot1 = rotate(t+10.0);\n        vec3 p1 = position;\n        p1.xz = rot1 * p1.xz;\n        vLayer1 = p1;\n\n        mat2 rot2 = rotate(t+30.0);\n        vec3 p2 = position;\n        p2.xy = rot2 * p2.xy;\n        vLayer2 = p2; \n\n        vPosition = position;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }`;\n  }\n\n  // 定义太阳的片段着色器\n  sunFragmentTexture() {\n    return `\n    uniform float uTime;\n    uniform samplerCube uPerlin;\n    varying vec2 vUv;\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec3 vLayer0;\n    varying vec3 vLayer1;\n    varying vec3 vLayer2;\n    varying vec3 eyeVector;\n    const float PI = 3.14159265359;\n\n    vec3 brightnessToColor (float b){\n      b *=0.25;\n      return (vec3(b, b*b, b*b*b*b)/0.25)*0.7;\n    }\n\n    // 将各个图层的纹理叠加整合\n    float sun(){\n      float sum = 0.0;\n      sum +=textureCube(uPerlin,vLayer0).r;\n      sum +=textureCube(uPerlin,vLayer1).r;\n      sum +=textureCube(uPerlin,vLayer2).r;\n      sum *=0.40;\n      return sum;\n    }\n\n    // 菲涅耳计算\n    float Fresnel(vec3 eyeVector,vec3 worldNormal){\n        return pow(1.3 + dot(eyeVector,worldNormal),4.0);\n    }\n\n    void main()\n    {\n      // 获取纹理\n      float brightness = sun();\n      // 增加对比度\n      brightness = brightness*4.0+1.0;\n      // 菲涅耳计算模拟反射和折射的光照\n      float fres = Fresnel(eyeVector,vNormal);\n      brightness += fres;\n      // 获取太阳的颜色\n      vec3 color = brightnessToColor(brightness); \n      gl_FragColor = vec4(color,1.0);\n    }`;\n  }\n\n  // 定义天空的顶点着色器\n  skyVertexShader() {\n    return `\n    varying vec3 vWorldPosition;\n\n    void main() {\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    }\n    `;\n  }\n\n  // 定义天空的片段着色器\n  skyFragmentShader() {\n    return `\n    uniform vec3 sunDirection;\n    uniform vec3 cameraPos;\n    uniform float turbidity;\n    uniform float rayleigh;\n    uniform float mieCoefficient;\n    uniform float mieDirectionalG;\n\n    varying vec3 vWorldPosition;\n\n    // 常量定义\n    const vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // 计算太阳的可见度\n    float sunIntensity(float zenithAngleCos) {\n      return max(0.0, 1.0 - exp(-((turbidity * 1.0) / (zenithAngleCos))));\n    }\n\n    // 计算散射\n    vec3 totalRayleigh(float zenithAngleCos) {\n      return rayleigh * vec3(0.0005 / zenithAngleCos);\n    }\n\n    vec3 totalMie(float zenithAngleCos) {\n      return mieCoefficient * vec3(0.0005 / zenithAngleCos);\n    }\n\n    void main() {\n      float sunfade = 1.0;\n\n      float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n      float inverse = 1.0 / (cos(zenithAngle) + 0.15 * pow(93.885 - (zenithAngle * 180.0 / PI), -1.253));\n\n      vec3 Fex = exp(-(totalRayleigh(cos(zenithAngle)) + totalMie(cos(zenithAngle))) * inverse);\n\n      vec3 sunE = sunIntensity(dot(sunDirection, up));\n\n      vec3 sunDirectionNormalized = normalize(sunDirection);\n\n      float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirectionNormalized);\n\n      float miePhase = pow(1.0 + cosTheta, 2.0) / pow(1.0 + mieDirectionalG, 2.0);\n\n      vec3 color = sunE * ((Fex * miePhase) + Fex);\n\n      color = pow(color, vec3(1.5)); // 调整亮度\n\n      gl_FragColor = vec4(color, 1.0);\n    }\n    `;\n  }\n\n  // 更新函数，在动画循环中调用\n  update(elapsedTime, renderer, camera) {\n    // 更新着色器中的 uTime\n    this.materialSun.uniforms.uTime.value = elapsedTime;\n\n    // 更新相机位置\n    this.materialSun.uniforms.cameraPosition.value.copy(camera.position);\n\n    // 更新天空材质中的相机位置\n    this.skyMaterial.uniforms.cameraPos.value.copy(camera.position);\n\n    // 更新天空材质中的太阳方向\n    const sunPosition = this.Sun.position.clone().normalize();\n    this.skyMaterial.uniforms.sunDirection.value.copy(sunPosition);\n  }\n}","map":{"version":3,"names":["THREE","Sun","constructor","position","x","y","z","scene","Scene","geometry","SphereGeometry","materialSun","ShaderMaterial","vertexShader","sunVertexTexture","fragmentShader","sunFragmentTexture","side","FrontSide","uniforms","uTime","value","uPerlin","ucameraPosition","Vector3","Mesh","set","add","skyGeometry","skyMaterial","skyVertexShader","skyFragmentShader","BackSide","sunDirection","cameraPos","turbidity","rayleigh","mieCoefficient","mieDirectionalG","skyMesh","update","elapsedTime","renderer","camera","cameraPosition","copy","sunPosition","clone","normalize"],"sources":["E:/three.js/three.js-demo/three-city/city/src/three/mesh/sun.js"],"sourcesContent":["// Sun.js\r\n\r\nimport * as THREE from 'three';\r\n\r\nexport default class Sun {\r\n  constructor(position = { x: 0, y: 0, z: 0 }) {\r\n    // 创建太阳的主场景\r\n    this.scene = new THREE.Scene();\r\n\r\n    // 创建太阳几何体\r\n    const geometry = new THREE.SphereGeometry(2.0, 32, 32);\r\n\r\n    // 创建主太阳材质\r\n    this.materialSun = new THREE.ShaderMaterial({\r\n      vertexShader: this.sunVertexTexture(),\r\n      fragmentShader: this.sunFragmentTexture(),\r\n      side: THREE.FrontSide,\r\n      uniforms: {\r\n        uTime: { value: 0 },\r\n        uPerlin: { value: null },\r\n        ucameraPosition: { value: new THREE.Vector3() },\r\n      },\r\n    });\r\n\r\n    // 创建太阳网格并添加到场景中\r\n    this.Sun = new THREE.Mesh(geometry, this.materialSun);\r\n    this.Sun.position.set(position.x, position.y, position.z);\r\n    this.scene.add(this.Sun);\r\n\r\n    // 创建天空球体\r\n    const skyGeometry = new THREE.SphereGeometry(5000, 32, 32);\r\n    this.skyMaterial = new THREE.ShaderMaterial({\r\n      vertexShader: this.skyVertexShader(),\r\n      fragmentShader: this.skyFragmentShader(),\r\n      side: THREE.BackSide,\r\n      uniforms: {\r\n        sunDirection: { value: new THREE.Vector3() },\r\n        cameraPos: { value: new THREE.Vector3() },\r\n        turbidity: { value: 10 },\r\n        rayleigh: { value: 2 },\r\n        mieCoefficient: { value: 0.005 },\r\n        mieDirectionalG: { value: 0.8 },\r\n      },\r\n    });\r\n\r\n    this.skyMesh = new THREE.Mesh(skyGeometry, this.skyMaterial);\r\n    this.scene.add(this.skyMesh);\r\n  }\r\n\r\n  // 定义太阳的顶点着色器\r\n  sunVertexTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    uniform vec3 ucameraPosition;\r\n    varying vec2 vUv;\r\n    varying vec3 vPosition;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    varying vec3 vNormal;\r\n\r\n    // 旋转矩阵\r\n    mat2 rotate(float a){\r\n        float s = sin(a);\r\n        float c = cos(a);\r\n        return mat2(c,-s,s,c);\r\n    } \r\n\r\n    void main()\r\n    {\r\n        // uv坐标\r\n        vUv = uv;\r\n        // 顶点法线\r\n        vNormal = normal;\r\n        // 世界坐标系\r\n        vec4 WorldPosition = modelMatrix * vec4 (position,1.0);\r\n        // 顶点到相机的向量\r\n        eyeVector = normalize(WorldPosition.xyz - ucameraPosition);\r\n\r\n        // 分别求围绕各个轴所进行的顶点旋转\r\n        float t = uTime * 0.03;\r\n        mat2 rot = rotate(t);\r\n\r\n        vec3 p0 = position;\r\n        p0.yz = rot * p0.yz;\r\n        vLayer0 = p0;\r\n\r\n        mat2 rot1 = rotate(t+10.0);\r\n        vec3 p1 = position;\r\n        p1.xz = rot1 * p1.xz;\r\n        vLayer1 = p1;\r\n\r\n        mat2 rot2 = rotate(t+30.0);\r\n        vec3 p2 = position;\r\n        p2.xy = rot2 * p2.xy;\r\n        vLayer2 = p2; \r\n\r\n        vPosition = position;\r\n\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义太阳的片段着色器\r\n  sunFragmentTexture() {\r\n    return `\r\n    uniform float uTime;\r\n    uniform samplerCube uPerlin;\r\n    varying vec2 vUv;\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec3 vLayer0;\r\n    varying vec3 vLayer1;\r\n    varying vec3 vLayer2;\r\n    varying vec3 eyeVector;\r\n    const float PI = 3.14159265359;\r\n\r\n    vec3 brightnessToColor (float b){\r\n      b *=0.25;\r\n      return (vec3(b, b*b, b*b*b*b)/0.25)*0.7;\r\n    }\r\n\r\n    // 将各个图层的纹理叠加整合\r\n    float sun(){\r\n      float sum = 0.0;\r\n      sum +=textureCube(uPerlin,vLayer0).r;\r\n      sum +=textureCube(uPerlin,vLayer1).r;\r\n      sum +=textureCube(uPerlin,vLayer2).r;\r\n      sum *=0.40;\r\n      return sum;\r\n    }\r\n\r\n    // 菲涅耳计算\r\n    float Fresnel(vec3 eyeVector,vec3 worldNormal){\r\n        return pow(1.3 + dot(eyeVector,worldNormal),4.0);\r\n    }\r\n\r\n    void main()\r\n    {\r\n      // 获取纹理\r\n      float brightness = sun();\r\n      // 增加对比度\r\n      brightness = brightness*4.0+1.0;\r\n      // 菲涅耳计算模拟反射和折射的光照\r\n      float fres = Fresnel(eyeVector,vNormal);\r\n      brightness += fres;\r\n      // 获取太阳的颜色\r\n      vec3 color = brightnessToColor(brightness); \r\n      gl_FragColor = vec4(color,1.0);\r\n    }`;\r\n  }\r\n\r\n  // 定义天空的顶点着色器\r\n  skyVertexShader() {\r\n    return `\r\n    varying vec3 vWorldPosition;\r\n\r\n    void main() {\r\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n      vWorldPosition = worldPosition.xyz;\r\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\r\n    }\r\n    `;\r\n  }\r\n\r\n  // 定义天空的片段着色器\r\n  skyFragmentShader() {\r\n    return `\r\n    uniform vec3 sunDirection;\r\n    uniform vec3 cameraPos;\r\n    uniform float turbidity;\r\n    uniform float rayleigh;\r\n    uniform float mieCoefficient;\r\n    uniform float mieDirectionalG;\r\n\r\n    varying vec3 vWorldPosition;\r\n\r\n    // 常量定义\r\n    const vec3 up = vec3(0.0, 1.0, 0.0);\r\n\r\n    // 计算太阳的可见度\r\n    float sunIntensity(float zenithAngleCos) {\r\n      return max(0.0, 1.0 - exp(-((turbidity * 1.0) / (zenithAngleCos))));\r\n    }\r\n\r\n    // 计算散射\r\n    vec3 totalRayleigh(float zenithAngleCos) {\r\n      return rayleigh * vec3(0.0005 / zenithAngleCos);\r\n    }\r\n\r\n    vec3 totalMie(float zenithAngleCos) {\r\n      return mieCoefficient * vec3(0.0005 / zenithAngleCos);\r\n    }\r\n\r\n    void main() {\r\n      float sunfade = 1.0;\r\n\r\n      float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\r\n      float inverse = 1.0 / (cos(zenithAngle) + 0.15 * pow(93.885 - (zenithAngle * 180.0 / PI), -1.253));\r\n\r\n      vec3 Fex = exp(-(totalRayleigh(cos(zenithAngle)) + totalMie(cos(zenithAngle))) * inverse);\r\n\r\n      vec3 sunE = sunIntensity(dot(sunDirection, up));\r\n\r\n      vec3 sunDirectionNormalized = normalize(sunDirection);\r\n\r\n      float cosTheta = dot(normalize(vWorldPosition - cameraPos), sunDirectionNormalized);\r\n\r\n      float miePhase = pow(1.0 + cosTheta, 2.0) / pow(1.0 + mieDirectionalG, 2.0);\r\n\r\n      vec3 color = sunE * ((Fex * miePhase) + Fex);\r\n\r\n      color = pow(color, vec3(1.5)); // 调整亮度\r\n\r\n      gl_FragColor = vec4(color, 1.0);\r\n    }\r\n    `;\r\n  }\r\n\r\n  // 更新函数，在动画循环中调用\r\n  update(elapsedTime, renderer, camera) {\r\n    // 更新着色器中的 uTime\r\n    this.materialSun.uniforms.uTime.value = elapsedTime;\r\n\r\n    // 更新相机位置\r\n    this.materialSun.uniforms.cameraPosition.value.copy(camera.position);\r\n\r\n    // 更新天空材质中的相机位置\r\n    this.skyMaterial.uniforms.cameraPos.value.copy(camera.position);\r\n\r\n    // 更新天空材质中的太阳方向\r\n    const sunPosition = this.Sun.position.clone().normalize();\r\n    this.skyMaterial.uniforms.sunDirection.value.copy(sunPosition);\r\n  }\r\n}\r\n"],"mappings":"AAAA;;AAEA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,eAAe,MAAMC,GAAG,CAAC;EACvBC,WAAWA,CAACC,QAAQ,GAAG;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,EAAE;IAC3C;IACA,IAAI,CAACC,KAAK,GAAG,IAAIP,KAAK,CAACQ,KAAK,CAAC,CAAC;;IAE9B;IACA,MAAMC,QAAQ,GAAG,IAAIT,KAAK,CAACU,cAAc,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC;;IAEtD;IACA,IAAI,CAACC,WAAW,GAAG,IAAIX,KAAK,CAACY,cAAc,CAAC;MAC1CC,YAAY,EAAE,IAAI,CAACC,gBAAgB,CAAC,CAAC;MACrCC,cAAc,EAAE,IAAI,CAACC,kBAAkB,CAAC,CAAC;MACzCC,IAAI,EAAEjB,KAAK,CAACkB,SAAS;MACrBC,QAAQ,EAAE;QACRC,KAAK,EAAE;UAAEC,KAAK,EAAE;QAAE,CAAC;QACnBC,OAAO,EAAE;UAAED,KAAK,EAAE;QAAK,CAAC;QACxBE,eAAe,EAAE;UAAEF,KAAK,EAAE,IAAIrB,KAAK,CAACwB,OAAO,CAAC;QAAE;MAChD;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,CAACvB,GAAG,GAAG,IAAID,KAAK,CAACyB,IAAI,CAAChB,QAAQ,EAAE,IAAI,CAACE,WAAW,CAAC;IACrD,IAAI,CAACV,GAAG,CAACE,QAAQ,CAACuB,GAAG,CAACvB,QAAQ,CAACC,CAAC,EAAED,QAAQ,CAACE,CAAC,EAAEF,QAAQ,CAACG,CAAC,CAAC;IACzD,IAAI,CAACC,KAAK,CAACoB,GAAG,CAAC,IAAI,CAAC1B,GAAG,CAAC;;IAExB;IACA,MAAM2B,WAAW,GAAG,IAAI5B,KAAK,CAACU,cAAc,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC;IAC1D,IAAI,CAACmB,WAAW,GAAG,IAAI7B,KAAK,CAACY,cAAc,CAAC;MAC1CC,YAAY,EAAE,IAAI,CAACiB,eAAe,CAAC,CAAC;MACpCf,cAAc,EAAE,IAAI,CAACgB,iBAAiB,CAAC,CAAC;MACxCd,IAAI,EAAEjB,KAAK,CAACgC,QAAQ;MACpBb,QAAQ,EAAE;QACRc,YAAY,EAAE;UAAEZ,KAAK,EAAE,IAAIrB,KAAK,CAACwB,OAAO,CAAC;QAAE,CAAC;QAC5CU,SAAS,EAAE;UAAEb,KAAK,EAAE,IAAIrB,KAAK,CAACwB,OAAO,CAAC;QAAE,CAAC;QACzCW,SAAS,EAAE;UAAEd,KAAK,EAAE;QAAG,CAAC;QACxBe,QAAQ,EAAE;UAAEf,KAAK,EAAE;QAAE,CAAC;QACtBgB,cAAc,EAAE;UAAEhB,KAAK,EAAE;QAAM,CAAC;QAChCiB,eAAe,EAAE;UAAEjB,KAAK,EAAE;QAAI;MAChC;IACF,CAAC,CAAC;IAEF,IAAI,CAACkB,OAAO,GAAG,IAAIvC,KAAK,CAACyB,IAAI,CAACG,WAAW,EAAE,IAAI,CAACC,WAAW,CAAC;IAC5D,IAAI,CAACtB,KAAK,CAACoB,GAAG,CAAC,IAAI,CAACY,OAAO,CAAC;EAC9B;;EAEA;EACAzB,gBAAgBA,CAAA,EAAG;IACjB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAE,kBAAkBA,CAAA,EAAG;IACnB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;EACJ;;EAEA;EACAc,eAAeA,CAAA,EAAG;IAChB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACH;;EAEA;EACAC,iBAAiBA,CAAA,EAAG;IAClB,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;EACH;;EAEA;EACAS,MAAMA,CAACC,WAAW,EAAEC,QAAQ,EAAEC,MAAM,EAAE;IACpC;IACA,IAAI,CAAChC,WAAW,CAACQ,QAAQ,CAACC,KAAK,CAACC,KAAK,GAAGoB,WAAW;;IAEnD;IACA,IAAI,CAAC9B,WAAW,CAACQ,QAAQ,CAACyB,cAAc,CAACvB,KAAK,CAACwB,IAAI,CAACF,MAAM,CAACxC,QAAQ,CAAC;;IAEpE;IACA,IAAI,CAAC0B,WAAW,CAACV,QAAQ,CAACe,SAAS,CAACb,KAAK,CAACwB,IAAI,CAACF,MAAM,CAACxC,QAAQ,CAAC;;IAE/D;IACA,MAAM2C,WAAW,GAAG,IAAI,CAAC7C,GAAG,CAACE,QAAQ,CAAC4C,KAAK,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC;IACzD,IAAI,CAACnB,WAAW,CAACV,QAAQ,CAACc,YAAY,CAACZ,KAAK,CAACwB,IAAI,CAACC,WAAW,CAAC;EAChE;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}